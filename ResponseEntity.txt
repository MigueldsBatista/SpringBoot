package com.example.vendas.rest.controller;


import java.util.List;
import java.util.Optional;

import org.springframework.data.domain.Example;

import org.springframework.data.domain.ExampleMatcher;

import org.springframework.http.ResponseEntity;

import org.springframework.web.bind.annotation.RestController;

import com.example.vendas.domain.entity.Cliente;
import com.example.vendas.domain.repository.Clientes;


import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;


//NAO PODEMOS APONTAR DOIS METODOS PARA MESMA URL!


@RestController//similar a Controller, mas os metodos ja tem anotados com response body
@RequestMapping("/api/clientes/")
public class ClienteController {
    private Clientes clientes;

    ClienteController(Clientes clientes){
        this.clientes=clientes;
    }

    //ao inves de usar o Request mapping e especificar o get, posso usar direto o getMapping

    @GetMapping("{id}")   
    public ResponseEntity getClienteById(@PathVariable Integer id){
        Optional<Cliente> cliente=clientes.findById(id);

        if(cliente.isPresent()){
            return ResponseEntity.ok(cliente.get());//200
        }
        
        return ResponseEntity.notFound().build();//404
    }
    @PostMapping//root
    public ResponseEntity save( @RequestBody Cliente cliente){
        Cliente clienteSalvo = clientes.save(cliente);
        return ResponseEntity.ok(clienteSalvo);

    }
    

    @DeleteMapping("{id}")
    public ResponseEntity delete(@PathVariable Integer id){
        Optional <Cliente> cliente = clientes.findById(id);
        if(cliente.isPresent()){
            clientes.delete(cliente.get());
            return ResponseEntity.noContent().build();//No content = status de sucesso porem sem retorno no corpo
        }
        return ResponseEntity.notFound().build();

    }
    @PutMapping("{id}")//PUT mapping atualiza completamente um recurso existente
    public ResponseEntity update(
        @PathVariable Integer id,
        @RequestBody Cliente cliente){

        return clientes
        .findById(id)
        .map(clienteExistente ->{
            cliente.setId(clienteExistente.getId());
            clientes.save(cliente);//mantem o ip porem troca todos os dados
            return ResponseEntity.noContent().build();
        }).orElseGet(() -> ResponseEntity.notFound().build());
    }
 
    @GetMapping//root
    public ResponseEntity find(Cliente filtro){
        ExampleMatcher matcher = ExampleMatcher
                                                .matching()
                                                .withIgnoreCase()
                                                .withStringMatcher(ExampleMatcher.StringMatcher.CONTAINING);
 
        Example example = Example.of(filtro, matcher);
        List <Cliente> lista = clientes.findAll(example);
        return ResponseEntity.ok(lista); 

    }
    


}

 /*
 
 Outras formas de se trabalhar

 @RequestMapping(
value = "/hello/{nome}", //"home/{nome}",variavel na url, posso definir mais de um
method = RequestMethod.GET,
consumes={"application/json", "application/xml"},//opcional, posso decidir o tipo de dados que serao consumidos|JSON POR PADRAO
produces = {"application/json", "application/xml"}//opcional, posso decidir o tipo de dados que serao retornados|JSON POR PADRAO
        )//indica que isso vai ser o corpo do retorno | JSON por padrao
public String helloCliente(@PathVariable("nome") String nomeCliente){
return String.format("Hello %s", nomeCliente);

    }

         */